# 最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。

例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

 
示例 1：

输入：nums = [10,9,2,5,3,7,101,18]

输出：4

解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

示例 2：

输入：nums = [0,1,0,3,2,3]

输出：4

示例 3：

输入：nums = [7,7,7,7,7,7,7]

输出：1
 

提示：

* 1 <= nums.length <= 2500
* -104 <= nums[i] <= 104
 

进阶：

你能将算法的时间复杂度降低到 O(n log(n)) 吗?



# 动态规划

1. 定义状态

定义 dp[i] 为 以 nums[i] 结尾的最长递增子序列的长度。

例如，若 nums = [0,1,0,3,2,3]，则：

dp[3] 表示以 nums[3]=3 结尾的最长递增子序列的长度（即子序列 [0,1,3]，长度为 3）。

2. 初始条件

每个元素本身可以视为长度为 1 的子序列，因此初始化：

dp[i] = 1（所有位置初始值为 1）。

3. 状态转移的逻辑

我们需要找到所有在 nums[i] 之前且比它小的元素 nums[j]（j < i），然后将 nums[i] 接在这些子序列的末尾，形成新的递增子序列。

例如，假设 nums[i] = 3，前面有 nums[j] = 0,1,0 都比它小，则 dp[i] 可以取这些 dp[j] 中的最大值加 1。

状态转移方程可以表示为：

dp[i] = max(dp[j] + 1) 对所有的 j < i 且 nums[j] < nums[i]

执行过程：

1.初始化：

dp 数组的每个元素初始化为 1，因为每个元素本身可以视为一个长度为 1 的子序列。

maxLen 初始化为 1，记录全局最长子序列长度。

2.双重循环：

外层循环：遍历数组中的每个元素 nums[i]（从第二个元素开始）。

内层循环：遍历 nums[i] 之前的所有元素 nums[j]。

如果 nums[j] < nums[i]，说明 nums[i] 可以接在 nums[j] 后面形成一个更长的递增子序列。

更新 dp[i] 为 dp[j] + 1 和当前 dp[i] 的较大值。

3.更新全局最大值：

每次计算完 dp[i] 后，用 maxLen 记录当前最长子序列的长度。



```js
/**
 * 使用动态规划找到最长严格递增子序列的长度
 * @param {number[]} nums 输入的整数数组
 * @return {number} 最长递增子序列的长度
 */
function lengthOfLIS(nums) {
    if (nums.length === 0) return 0;

    // dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度
    const dp = new Array(nums.length).fill(1); // 初始每个元素自身长度为1
    let maxLen = 1; // 记录全局最大值

    for (let i = 1; i < nums.length; i++) {
        // 遍历 i 之前的所有元素，寻找可以接在 nums[i] 前面的更小元素
        for (let j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                // 如果 nums[j] < nums[i]，则可以接在 j 后面形成更长的子序列
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        // 更新全局最大值
        maxLen = Math.max(maxLen, dp[i]);
    }

    return maxLen;
}

```