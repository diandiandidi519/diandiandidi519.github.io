# 最长回文子串

给你一个字符串 s，找到 s 中最长的 回文 子串。

 

示例 1：

输入：s = "babad"

输出："bab"

解释："aba" 同样是符合题意的答案。

示例 2：

输入：s = "cbbd"

输出："bb"
 

提示：

* 1 <= s.length <= 1000
* s 仅由数字和英文字母组成


# 动态规划

方法思路

定义状态：使用二维数组 dp[i][j] 表示字符串 s 从索引 i 到 j 的子串是否为回文。

状态转移方程：

如果 s[i] != s[j]，则 dp[i][j] = false。

如果 s[i] == s[j]：

当子串长度 ≤ 3 时，直接判定为回文。

否则，dp[i][j] 取决于 dp[i+1][j-1] 是否为回文。

初始化：所有长度为 1 的子串都是回文。

遍历顺序：按子串长度从小到大遍历，填充 dp 数组并更新最长回文子串的起始位置和长度。

```js
function longestPalindrome(s) {
    const n = s.length;
    if (n === 0) return '';
    let maxLen = 1;
    let start = 0;
    const dp = Array.from({ length: n }, () => new Array(n).fill(false));

    // 初始化所有长度为1的子串为回文
    for (let i = 0; i < n; i++) {
        dp[i][i] = true;
    }

    // 遍历所有可能的子串长度
    for (let L = 2; L <= n; L++) {
        for (let i = 0; i <= n - L; i++) {
            const j = i + L - 1; // 子串结束索引
            if (s[i] !== s[j]) {
                dp[i][j] = false;
            } else {
                if (L <= 2) {
                    dp[i][j] = true;
                } else {
                    dp[i][j] = dp[i + 1][j - 1];
                }
            }

            // 更新最长回文子串信息
            if (dp[i][j] && L > maxLen) {
                maxLen = L;
                start = i;
            }
        }
    }

    return s.substring(start, start + maxLen);
}
```

# 示例推演过程

我们以示例1 `s = "babad"` 为例，逐步演示动态规划表格的填充过程，并观察最长回文子串的发现过程。

---

#### **步骤1：初始化**
所有长度为1的子串都是回文（即 `dp[i][i] = true`）：
```
索引 | 0(b) | 1(a) | 2(b) | 3(a) | 4(d)
------------------------------------------
0(b) | T    |      |      |      |     
1(a) |      | T    |      |      |     
2(b) |      |      | T    |      |     
3(a) |      |      |      | T    |     
4(d) |      |      |      |      | T   
```

---

#### **步骤2：遍历长度为2的子串（L=2）**
检查所有长度为2的子串是否为回文：
- `i=0, j=1`：`s[0]=b` vs `s[1]=a` → **不匹配** → `dp[0][1] = false`
- `i=1, j=2`：`s[1]=a` vs `s[2]=b` → **不匹配** → `dp[1][2] = false`
- `i=2, j=3`：`s[2]=b` vs `s[3]=a` → **不匹配** → `dp[2][3] = false`
- `i=3, j=4`：`s[3]=a` vs `s[4]=d` → **不匹配** → `dp[3][4] = false`

此时表格无变化，最长回文仍为1。

---

#### **步骤3：遍历长度为3的子串（L=3）**
检查所有长度为3的子串是否为回文：
- `i=0, j=2`：`s[0]=b` vs `s[2]=b` → **匹配**  
  中间子串 `dp[1][1] = true` → `dp[0][2] = true`  
  更新最长回文：`start=0`, `maxLen=3`
  
- `i=1, j=3`：`s[1]=a` vs `s[3]=a` → **匹配**  
  中间子串 `dp[2][2] = true` → `dp[1][3] = true`  
  更新最长回文：`start=1`, `maxLen=3`
  
- `i=2, j=4`：`s[2]=b` vs `s[4]=d` → **不匹配** → `dp[2][4] = false`

更新后的表格：
```
索引 | 0(b) | 1(a) | 2(b) | 3(a) | 4(d)
------------------------------------------
0(b) | T    | F    | T    |      |     
1(a) |      | T    | F    | T    |     
2(b) |      |      | T    | F    | F   
3(a) |      |      |      | T    | F   
4(d) |      |      |      |      | T   
```

---

#### **步骤4：遍历长度为4的子串（L=4）**
检查所有长度为4的子串是否为回文：
- `i=0, j=3`：`s[0]=b` vs `s[3]=a` → **不匹配** → `dp[0][3] = false`
- `i=1, j=4`：`s[1]=a` vs `s[4]=d` → **不匹配** → `dp[1][4] = false`

表格无变化，最长回文仍为3。

---

#### **步骤5：遍历长度为5的子串（L=5）**
检查整个字符串是否为回文：
- `i=0, j=4`：`s[0]=b` vs `s[4]=d` → **不匹配** → `dp[0][4] = false`

最终表格：
```
索引 | 0(b) | 1(a) | 2(b) | 3(a) | 4(d)
------------------------------------------
0(b) | T    | F    | T    | F    | F   
1(a) |      | T    | F    | T    | F   
2(b) |      |      | T    | F    | F   
3(a) |      |      |      | T    | F   
4(d) |      |      |      |      | T   
```

---

#### **最终结果**
最长回文子串长度为3，有两个候选：
- `s.substring(0, 3) = "bab"`
- `s.substring(1, 4) = "aba"`

代码会返回第一个找到的（即 `start=0`），但根据示例解释两者均有效。动态规划的遍历顺序可能影响最终结果，但题目接受任意正确答案。