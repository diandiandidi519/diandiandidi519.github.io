# 最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。

两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

 

示例 1：

输入：text1 = "abcde", text2 = "ace" 

输出：3  

解释：最长公共子序列是 "ace" ，它的长度为 3 。

示例 2：

输入：text1 = "abc", text2 = "abc"

输出：3

解释：最长公共子序列是 "abc" ，它的长度为 3 。

示例 3：

输入：text1 = "abc", text2 = "def"

输出：0

解释：两个字符串没有公共子序列，返回 0 。
 

提示：

* 1 <= text1.length, text2.length <= 1000

* text1 和 text2 仅由小写英文字符组成。

# 题解

动态规划推导

定义状态：设 dp[i][j] 表示字符串 text1 的前 i 个字符和 text2 的前 j 个字符的最长公共子序列长度。

初始状态：当 i=0 或 j=0 时，其中一个字符串为空，LCS长度为0，即 dp[0][j] = dp[i][0] = 0。

状态转移：

若 text1[i-1] == text2[j-1]，则当前字符属于LCS，故 dp[i][j] = dp[i-1][j-1] + 1。

否则，取左方或上方的最大值，即 dp[i][j] = max(dp[i-1][j], dp[i][j-1])。

```js
function longestCommonSubsequence(text1, text2) {
    const m = text1.length, n = text2.length;
    // 创建 (m+1) x (n+1) 的二维数组，初始化为0
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (text1[i-1] === text2[j-1]) {
                // 字符相等，长度加1
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                // 取左方或上方的最大值
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[m][n];
}
```

为什么数组的大小为(m+1)*(n+1)

在解决最长公共子序列（LCS）问题时，动态规划数组的大小设为 **(m+1)×(n+1)** 的原因如下：

---

### 1. **状态定义的完整性**
动态规划的核心是定义状态 `dp[i][j]`，表示：
- **`text1` 的前 `i` 个字符**（即从 `text1[0]` 到 `text1[i-1]`）
- **`text2` 的前 `j` 个字符**（即从 `text2[0]` 到 `text2[j-1]`）
的最长公共子序列长度。

此时：
- `i` 的取值范围是 `0 ≤ i ≤ m`（共 `m+1` 种可能）
- `j` 的取值范围是 `0 ≤ j ≤ n`（共 `n+1` 种可能）

因此，数组需要 **(m+1) 行 × (n+1) 列**才能覆盖所有可能的子问题。

---

### 2. **边界条件的处理**
当 `i=0` 或 `j=0` 时，表示至少有一个字符串为空，此时 LCS 长度为 **0**。例如：
- `dp[0][j] = 0`（`text1` 为空）
- `dp[i][0] = 0`（`text2` 为空）

若数组大小为 `m×n`，则无法表示 `i=0` 或 `j=0` 的边界情况，导致无法初始化。

---

### 3. **状态转移的索引对齐**
在状态转移中，当 `text1[i-1] == text2[j-1]` 时，需要取 `dp[i-1][j-1]` 的值。例如：
- `i=1` 对应 `text1[0]`（第一个字符）
- `j=1` 对应 `text2[0]`（第一个字符）

如果数组大小为 `m×n`，当 `i=m` 或 `j=n` 时，访问 `text1[m-1]` 或 `text2[n-1]` 会导致越界。

---

### 4. **示例说明**
以 `text1 = "abc"`（m=3）和 `text2 = "ace"`（n=3）为例：
- 数组大小为 **(3+1)×(3+1) = 4×4**，对应状态如下：

  | i\j | 0   | 1(a) | 2(c) | 3(e) |
  |-----|-----|------|------|------|
  | 0   | 0   | 0    | 0    | 0    |
  | 1(a)| 0   | 1    | 1    | 1    |
  | 2(b)| 0   | 1    | 1    | 1    |
  | 3(c)| 0   | 1    | 2    | 2    |

- `dp[3][3] = 2` 对应 LCS 为 `"ac"`。

---

### 5. **空间复杂度优化**
虽然数组大小为 `(m+1)×(n+1)`，但可通过滚动数组优化至 `O(n)` 空间，但原理不变。

---

### 总结
数组大小为 **(m+1)×(n+1)** 是为了：
1. 覆盖所有可能的子问题（包括空字符串）。
2. 正确处理边界条件和索引对齐。
3. 确保状态转移的逻辑一致性和代码简洁性。