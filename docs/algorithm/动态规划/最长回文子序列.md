## 题目描述

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

示例 1：

输入：s = "bbbab"

输出：4

解释：一个可能的最长回文子序列为 "bbbb" 。

示例 2：

输入：s = "cbbd"

输出：2

解释：一个可能的最长回文子序列为 "bb" 。

提示：

- 1 <= s.length <= 1000
- s 仅由小写英文字母组成

## 题解

1. 定义状态

dp[i][j] 代表字符串 s[i]和 s[j 之间]最长回文子序列

2. 状态转移

根据 s[i] 和 s[j] 是否相等，分两种情况：

​ 情况 1：s[i] == s[j]

此时可将这两个字符加入 [i+1, j-1] 的最优解，得到：dp[i][j] = dp[i+1][j-1] + 2

例如，子串 "abba" 的首尾字符相等，其 LPS 长度由中间部分 "bb" 的 LPS（2）加上 2，结果为 4。

​ 情况 2：s[i] != s[j]

此时需分别排除左边界或右边界字符，取最大值：

去掉左端点：dp[i][j-1]

去掉右端点：dp[i+1][j]

即 dp[i][j] = Math.max(dp[i][j-1], dp[i+1][j])

例如，子串 "abc" 的首尾字符不相等，其 LPS 为 "ab" 或 "bc" 的 LPS 最大值（即 1）

3. 初始化

每个字符串都是一个回文子序列

dp[i][i] = 1

当 i > j 时，区间非法，默认值为 0

代码实现

```js
function longestPalindromeSubseq(s) {
  const n = s.length
  // 创建二维数组并初始化对角线为1
  const dp = Array.from({ length: n }, () => new Array(n).fill(0))
  for (let i = 0; i < n; i++) {
    dp[i][i] = 1
  }

  // 倒序遍历i，j从i+1开始向右扩展
  for (let i = n - 1; i >= 0; i--) {
    for (let j = i + 1; j < n; j++) {
      if (s[i] === s[j]) {
        // 两端字符相等，依赖中间子问题的解
        dp[i][j] = dp[i + 1][j - 1] + 2
      } else {
        // 取左或右扩展的最大值
        dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j])
      }
    }
  }

  return dp[0][n - 1]
}
```
