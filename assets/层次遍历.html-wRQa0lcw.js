import{_ as s,c as a,b as p,o as e}from"./app-DwiXRcmX.js";const t={};function l(o,n){return e(),a("div",null,n[0]||(n[0]=[p(`<h1 id="二叉树的层序遍历" tabindex="-1"><a class="header-anchor" href="#二叉树的层序遍历"><span>二叉树的层序遍历</span></a></h1><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked" target="_blank" rel="noopener noreferrer">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p></p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="&#39;二叉树层次&#39;"></p><p>输入：root = [3,9,20,null,null,15,7]</p><p>输出：[[3],[9,20],[15,7]]</p><p>示例 2：</p><p>输入：root = [1]</p><p>输出：[[1]]</p><p>示例 3：</p><p>输入：root = [] 输出：[]</p><p></p><p>提示：</p><ul><li>树中节点数目在范围 [0, 2000] 内</li><li>-1000 &lt;= Node.val &lt;= 1000</li></ul><h1 id="题解" tabindex="-1"><a class="header-anchor" href="#题解"><span>题解</span></a></h1><p>二叉树的层次遍历，可以利用队列的特性，先进先出的概念</p><p>每遍历一个节点，将其左右子结点都推入队列里面</p><p>每次遍历一个新的层级的时候，获取当前队列的大小，也就是当前层次有多少个节点</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token comment">// 队列用来存储当前节点对应的左右子节点</span></span>
<span class="line">    <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span></span>
<span class="line">    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span>
<span class="line">    <span class="token comment">// 层次遍历肯定先遍历根节点</span></span>
<span class="line">    <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 当前层次有节点</span></span>
<span class="line">        <span class="token keyword">const</span> nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span>
<span class="line">        <span class="token comment">// 通过大小去记录当前层元素的个数</span></span>
<span class="line">        <span class="token keyword">let</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span>length</span>
<span class="line">        <span class="token keyword">while</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">// 队头元素出列</span></span>
<span class="line">            <span class="token keyword">const</span> front <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">            <span class="token keyword">if</span><span class="token punctuation">(</span>front<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>right<span class="token punctuation">)</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">            nodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>front<span class="token punctuation">.</span>value<span class="token punctuation">)</span></span>
<span class="line">            size<span class="token operator">--</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> result</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,21)]))}const i=s(t,[["render",l],["__file","层次遍历.html.vue"]]),u=JSON.parse('{"path":"/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.html","title":"二叉树的层序遍历","lang":"en-US","frontmatter":{},"headers":[],"git":{"updatedTime":1740290618000,"contributors":[{"name":"wangshuya.wsy","username":"wangshuya.wsy","email":"wangshuya.wsy@bytedance.com","commits":2,"url":"https://github.com/wangshuya.wsy"}]},"filePathRelative":"algorithm/二叉树/层次遍历.md"}');export{i as comp,u as data};
