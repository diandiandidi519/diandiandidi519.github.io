import{_ as s,c as a,b as t,o as p}from"./app-x7oXx1JU.js";const e={};function o(c,n){return p(),a("div",null,n[0]||(n[0]=[t(`<h2 id="最长公共子序列" tabindex="-1"><a class="header-anchor" href="#最长公共子序列"><span>最长公共子序列</span></a></h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。</p><p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p>示例 1：</p><p>输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;</p><p>输出：3</p><p>解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</p><p>示例 2：</p><p>输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</p><p>输出：3</p><p>解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</p><p>示例 3：</p><p>输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</p><p>输出：0</p><p>解释：两个字符串没有公共子序列，返回 0 。</p><p>提示：</p><ul><li><p>1 &lt;= text1.length, text2.length &lt;= 1000</p></li><li><p>text1 和 text2 仅由小写英文字符组成。</p></li></ul><h2 id="题解" tabindex="-1"><a class="header-anchor" href="#题解"><span>题解</span></a></h2><p>动态规划推导</p><p>定义状态：设 dp[i][j] 表示字符串 text1 的前 i 个字符和 text2 的前 j 个字符的最长公共子序列长度。</p><p>初始状态：当 i=0 或 j=0 时，其中一个字符串为空，LCS 长度为 0，即 dp[0][j] = dp[i][0] = 0。</p><p>状态转移：</p><p>若 text1[i-1] == text2[j-1]，则当前字符属于 LCS，故 dp[i][j] = dp[i-1][j-1] + 1。</p><p>否则，取左方或上方的最大值，即 dp[i][j] = max(dp[i-1][j], dp[i][j-1])。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span><span class="token parameter">text1<span class="token punctuation">,</span> text2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> m <span class="token operator">=</span> text1<span class="token punctuation">.</span>length<span class="token punctuation">,</span></span>
<span class="line">    n <span class="token operator">=</span> text2<span class="token punctuation">.</span>length</span>
<span class="line">  <span class="token comment">// 创建 (m+1) x (n+1) 的二维数组，初始化为0</span></span>
<span class="line">  <span class="token keyword">const</span> dp <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">length</span><span class="token operator">:</span> m <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">Array</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>text1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> text2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 字符相等，长度加1</span></span>
<span class="line">        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span></span>
<span class="line">      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 取左方或上方的最大值</span></span>
<span class="line">        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么数组的大小为(m+1)*(n+1)</p><p>在解决最长公共子序列（LCS）问题时，动态规划数组的大小设为 <strong>(m+1)×(n+1)</strong> 的原因如下：</p><hr><ol><li><strong>状态定义的完整性</strong></li></ol><p>动态规划的核心是定义状态 <code>dp[i][j]</code>，表示：</p><ul><li><strong><code>text1</code> 的前 <code>i</code> 个字符</strong>（即从 <code>text1[0]</code> 到 <code>text1[i-1]</code>）</li><li><strong><code>text2</code> 的前 <code>j</code> 个字符</strong>（即从 <code>text2[0]</code> 到 <code>text2[j-1]</code>） 的最长公共子序列长度。</li></ul><p>此时：</p><ul><li><code>i</code> 的取值范围是 <code>0 ≤ i ≤ m</code>（共 <code>m+1</code> 种可能）</li><li><code>j</code> 的取值范围是 <code>0 ≤ j ≤ n</code>（共 <code>n+1</code> 种可能）</li></ul><p>因此，数组需要 <strong>(m+1) 行 × (n+1) 列</strong>才能覆盖所有可能的子问题。</p><hr><ol start="2"><li><strong>边界条件的处理</strong></li></ol><p>当 <code>i=0</code> 或 <code>j=0</code> 时，表示至少有一个字符串为空，此时 LCS 长度为 <strong>0</strong>。例如：</p><ul><li><code>dp[0][j] = 0</code>（<code>text1</code> 为空）</li><li><code>dp[i][0] = 0</code>（<code>text2</code> 为空）</li></ul><p>若数组大小为 <code>m×n</code>，则无法表示 <code>i=0</code> 或 <code>j=0</code> 的边界情况，导致无法初始化。</p><hr><ol start="3"><li><strong>状态转移的索引对齐</strong></li></ol><p>在状态转移中，当 <code>text1[i-1] == text2[j-1]</code> 时，需要取 <code>dp[i-1][j-1]</code> 的值。例如：</p><ul><li><code>i=1</code> 对应 <code>text1[0]</code>（第一个字符）</li><li><code>j=1</code> 对应 <code>text2[0]</code>（第一个字符）</li></ul><p>如果数组大小为 <code>m×n</code>，当 <code>i=m</code> 或 <code>j=n</code> 时，访问 <code>text1[m-1]</code> 或 <code>text2[n-1]</code> 会导致越界。</p><hr><ol start="4"><li><strong>示例说明</strong></li></ol><p>以 <code>text1 = &quot;abc&quot;</code>（m=3）和 <code>text2 = &quot;ace&quot;</code>（n=3）为例：</p><ul><li><p>数组大小为 <strong>(3+1)×(3+1) = 4×4</strong>，对应状态如下：</p><table><thead><tr><th>i\\j</th><th>0</th><th>1(a)</th><th>2(c)</th><th>3(e)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1(a)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2(b)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>3(c)</td><td>0</td><td>1</td><td>2</td><td>2</td></tr></tbody></table></li><li><p><code>dp[3][3] = 2</code> 对应 LCS 为 <code>&quot;ac&quot;</code>。</p></li></ul><hr><ol start="5"><li><strong>空间复杂度优化</strong></li></ol><p>虽然数组大小为 <code>(m+1)×(n+1)</code>，但可通过滚动数组优化至 <code>O(n)</code> 空间，但原理不变。</p><hr>`,54)]))}const i=s(e,[["render",o],["__file","最长公共子序列.html.vue"]]),u=JSON.parse('{"path":"/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"最长公共子序列","slug":"最长公共子序列","link":"#最长公共子序列","children":[]},{"level":2,"title":"题解","slug":"题解","link":"#题解","children":[]}],"git":{"updatedTime":1741163975000,"contributors":[{"name":"wangshuya.wsy","username":"wangshuya.wsy","email":"wangshuya.wsy@bytedance.com","commits":2,"url":"https://github.com/wangshuya.wsy"}],"changelog":[{"hash":"47f3c366de1ee4cd419369819e9d621fe969f933","date":1741163975000,"email":"wangshuya.wsy@bytedance.com","author":"wangshuya.wsy","message":"feat: 动态规划调整"},{"hash":"b725ec79a7123006ce87c9280e97eb0dd1db2542","date":1740834724000,"email":"wangshuya.wsy@bytedance.com","author":"wangshuya.wsy","message":"feat: 动态规划题解"}]},"filePathRelative":"algorithm/动态规划/最长公共子序列.md"}');export{i as comp,u as data};
