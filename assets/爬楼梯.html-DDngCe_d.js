import{_ as s,c as a,b as p,o as e}from"./app-D8niMc1Q.js";const t={};function l(o,n){return e(),a("div",null,n[0]||(n[0]=[p(`<h1 id="爬楼梯" tabindex="-1"><a class="header-anchor" href="#爬楼梯"><span>爬楼梯</span></a></h1><h2 id="题目描述" tabindex="-1"><a class="header-anchor" href="#题目描述"><span>题目描述</span></a></h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>示例 1：</p><p>输入：n = 2</p><p>输出：2</p><p>解释：有两种方法可以爬到楼顶。</p><ol><li><p>1 阶 + 1 阶</p></li><li><p>2 阶</p></li></ol><p>示例 2：</p><p>输入：n = 3</p><p>输出：3</p><p>解释：有三种方法可以爬到楼顶。</p><ol><li><p>1 阶 + 1 阶 + 1 阶</p></li><li><p>1 阶 + 2 阶</p></li><li><p>2 阶 + 1 阶</p></li></ol><h1 id="题解" tabindex="-1"><a class="header-anchor" href="#题解"><span>题解</span></a></h1><h2 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划"><span>动态规划</span></a></h2><ol><li>定义子问题，明确状态和选择</li></ol><p>dp[i]代表到达第i个台阶的多少种方法，第i阶可以由dp[i-1]和dp[i-2]之和转移过来</p><ol start="2"><li>实现反复需要执行解决的子问题部分，动态转移方程</li></ol><p>dp[i] = dp[i-1] + dp[i-2]</p><ol start="3"><li>识别出边界问题</li></ol><p>dp[0] = 0</p><p>dp[1] = 1</p><p>dp[2] = 2</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">//dp[i]代表到达第i阶台阶的方法</span></span>
<span class="line">    <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token comment">//到达第1阶1种方法</span></span>
<span class="line">    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span></span>
<span class="line">    <span class="token comment">//到达第2阶两种方法</span></span>
<span class="line">    dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span></span>
<span class="line">    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,25)]))}const c=s(t,[["render",l],["__file","爬楼梯.html.vue"]]),r=JSON.parse('{"path":"/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%88%AC%E6%A5%BC%E6%A2%AF.html","title":"爬楼梯","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"题目描述","slug":"题目描述","link":"#题目描述","children":[]},{"level":2,"title":"动态规划","slug":"动态规划","link":"#动态规划","children":[]}],"git":{"updatedTime":1740999754000,"contributors":[{"name":"wangshuya.wsy","username":"wangshuya.wsy","email":"wangshuya.wsy@bytedance.com","commits":2,"url":"https://github.com/wangshuya.wsy"}]},"filePathRelative":"algorithm/动态规划/爬楼梯.md"}');export{c as comp,r as data};
